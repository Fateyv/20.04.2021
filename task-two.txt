
Pull request'ы позволяют вам рассказать другим о тех изменениях, которые вы разместили в своём GitHub-репозитории. Как только pull request отправлен, заинтересованные стороны рассматривают ваши изменения, обсуждают возможные правки или даже добавляют дополняющие коммиты, если нужно.

Говоря своим языком: Посылая pull request, вы говорите автору изначального репозитория (и всем заинтересованным лицам): «Смотрите, что я сделал, не хотите ли принять мои изменения и влить их в проект?»

Немного о моделях совместной разработки

На GitHub популярны две модели совместной разработки:
Модель «Fork + Pull» позволяет любому склонировать (fork) существующий репозиторий и сливать изменения в свой личный fork без необходимости иметь доступ к оригинальному репозиторию. Затем, изменения должны быть включены в исходный репозиторий его хозяином. Эта модель уменьшает количество телодвижений для новых contributors и популярна для open source проектов, так как позволяет людям работать независимо, без единого координирования.
Модель «общего репозитория» (The Shared Repository Model) чаще встречается у малых команд и организаций, работающих над закрытыми проектами. Каждый в команде имеет доступ «на запись» в один общий репозиторий, а для изолирования изменений применяются тематические ветви (topic branches).

Pull request'ы особенно полезны в модели «Fork + Pull», поскольку предоставляют способ уведомить мэйнтэйнеров проекта (т.е. хозяина оригинального репозитория) о изменениях в вашей копии репозитория. Впрочем, они так же полезны и в модели общего репозитория, где обычно используются для того, чтобы инициировать пересмотр или обсуждение кода перед тем, как включать его в основную ветвь разработки.

Делаем копию репозитория

Рассматривая первую модель разработки, необходимо иметь свою копию изначального репозитория, в которой и будет вестись работа, и изменения из которой и будут предлагаться затем автору изначального репозитория.

В рамках руководства, будем считать, что мы работаем над репозиторием Spoon-Knife пользователя octocat, а ваше имя пользователя — username.

Сделать это очень просто: на странице репозитория имеется кнопочка «Fork», которую и следует нажать.
Кнопка «Fork»

После чего, эту свою копию уже можно «стянуть» на свой компьютер:

git clone git@github.com:username/Spoon-Knife.git


Склонированный репозиторий имеет одну привязку к удалённому репозиторию, названную origin, которая указывает на вашу копию на GitHub, а не на оригинальный репозиторий, чтобы отслеживать изменения и в нём, вам нужно будет добавить другую привязку, названную, например, upstream.

cd Spoon-Knife
git remote add upstream git://github.com/octocat/Spoon-Knife.git
git fetch upstream


Делаем работу

Итак, в этой точке мы уже можем править код и делать коммиты. Если вы сделали все предыдущие шаги, чтобы потом вернуть ваши изменения в оригинальный репозиторий, то я настоятельно советую делать всю работу в отдельной тематической ветви разработки. Полезность этого станет ясна на этапе посылки pull request'а. Пускай она будет называться feature.

git checkout -b feature #Создаёт новую ветвь, названную "feature" и делает её активной


Вот, теперь творите добро (и пусть оно будет выражаться в коммитах).

Как только вы сделали работу (или её часть), отправьте её в свою копию репозитория на GitHub:

git push origin feature #Загружает изменения в текущей ветви в origin в ветвь feature


Возвращаем изменения: Pull request

Итак, всё сделано. Вы написали код, он у вас в ветви feature как у вас на компьютере, так и на GitHub'е. Осталось только «заслать» его в оригинальный репозиторий.

Идите на страницу вашей копии репозитория на GitHub, выбирайте ветвь feature и жмите кнопку Pull Request.
Подготовка к pull request'у

Далее вы попадёте на предпросмотровую страницу, на которой сможете ввести название и описание ваших изменений (название потом попадёт в описание мёрдж-коммита и станет достоянием общественности, учтите это).
Предпросмотр пулл реквеста, заполнение названия и описания

Там же вы можете посмотреть, какие коммиты попали в пулл реквест:
Предпросмотр пулл реквеста, коммиты

А так же общий diff всех изменений в пулл реквесте:
image

По умолчанию, пулл реквесты считаются основанными на самой часто интегрируемой ветви родительского репозитория. В этом случае username/Spoon-Knife был скопирован с octocat/Spoon-Knife, так что pull request считается основанным на ветке master репозитория octocat/Spoon-Knife. В большинстве случаев, это будет корректно, но если не так, то вы можете нажать на кнопку «Change Commits»

Вы попадёте в форму выбора базовой и исходной ветвей:
Выбор коммитов для отправки

Слева выбираете в какую ветку будут вливаться изменения в родительском репозитории, справа — какие изменения будут браться с вашего репозитория. По примеру: справа octocat/Spoon-Knife/master, слева username/Spoon-Knife/feature. Здесь вы можете указывать не только ветки, но так же теги и id отдельных коммитов в соответствующем репозитории.
ВАЖНО: Договоритесь с владельцем «родительского» репозитория, в какую ветку будете вливать изменения (он может написать это в README)

Изменение базового репозитория меняет и список людей, кто получит уведомление о пулл реквесте. Каждый, кто имеет право «на запись» в базовый репозиторий, получит письмо и увидит уведомление на главной GitHub'а, в следующий раз, как на него зайдёт.
Как только список коммитов вас удовлетворит, нажмите кнопку Update Commit Range.

Когда вы ввели название и описание и перепроверили список коммитов и изменения в файлы, попавшие в пулл реквест, нажмите кнопку Send pull request. Пулл реквест будет создан незамедлительно.

Что дальше?

Следите за вашим пулл-реквестом. Что прокомментируют люди, что скажет мэйнтэйнер, примет или нет ваш пулл реквест.

Помните, я говорил, что следует все изменения, которые пойдут в пулл, держать в отдельной ветке? Так вот, основное удобство: вы всегда можете добавить коммиты к уже существующему пулл реквесту, просто добавив их к этой ветке в вашем репозитории (да-да, просто git push origin feature, при условии, что вы указали в пулл реквесте feature как исходную ветвь)

При просмотре пулл реквеста, кроме названия, описания и коммитов, так же отображаются:
Комментарии, оставленные к пулл реквесту;
Дополнительные коммиты, добавленные к ветви пулл реквеста;
Комментарии к изменённым строкам или файлам, оставленные к любому из коммитов, включенных в пулл реквест.

В комментариях к пулл реквесту можно использовать Markdown, то есть можно вставлять изображения и использовать всё форматирование, поддерживаемое Markdown.

Когда ваш pull request примут, не забудьте слить изменения в свой репозиторий (или удалить его, если больше не нужен):
git checkout master
git pull upstream master
git push origin master

Так же можно удалить ветку, в которой велась разработка:
git branch -d feature #В локальном репозитории
git push origin :feature #В удалённом репозитории


Что следует делать, если работа заняла большое время и оригинальный репозиторий успел уйти вперёд?

Можно просто влить изменения из оригинального репозитория к себе:

git checkout master
git pull upstream master
git checkout feature
git merge master


Однако хозяину оригинального репозитория или, может быть, даже вам, не понравится наличие мёрж-коммитов и коммитов из master'а в списке коммитов на пулл. В таком случае вам стоит воспользоваться git rebase.

git checkout master
git pull upstream master
git checkout feature
git rebase master #Всё отличие только здесь


Прочитать про то, как работает rebase можно в официальном руководстве. Там имеются и очень понятные иллюстрации. Так же есть статья в помощи GitHub.
ВНИМАНИЕ: Пожалуйста, учтите, что git rebase меняет id коммитов! Поэтому, все действия с этой командой стоит выполнять только на локальном репозитории, до того, как эти коммиты станут общедоступны, т.е. до того, как вы их push'нули на гитхаб.

Если вы хозяин: Как принять pull request

Если пулл реквест удовлетворяет всем условиям, то кто-либо с правом «на запись» (т.е. может сделать push) в целевой репозиторий, должен принять pull request одним из многих методов. Ниже описаны три наиболее популярных метода:

Auto Merge (автослияние)

Во многих случаях можно попросить github автоматически принять пулл реквест, используя большую зелёную кнопку Merge Pull Request, которая сама вольёт изменения, создаст мёрж-коммит и закроет пулл реквест.
Кнопка автослияния
Подробнее можно почитать в этом хабратопике: Кнопка слияния на GitHub.

Fetch and Merge (скачать и слить)

Основной метод вливания изменений. Он требует добавления remote, ведущего к репозиторию человека, отправившего pull request, скачивания изменений с этого репозитория, объединения нужной ветви, исправления конфликтов и выгрузки обновлённой ветви обратно в исходный репозиторий:
git checkout master
git remote add username git://github.com/username/Spoon-Knife.git
git fetch username
git merge username/feature
git push origin master


Patch and Apply (пропатчить и принять)

Предыдущий метод работает хорошо, когда вы работаете в команде или постоянно принимаете изменения от одной и той же группы людей. Другой метод немного быстрее в единичных случаях при использовании git-am.

У каждого пулл реквеста есть свой .patch URL, с которого можно скачать текстовый патч, чтобы скормить его команде git-am:
git checkout master
curl https://github.com/octocat/Spoon-Knife/pull/50.patch | git am
git push origin master


Закрытие пулл реквеста

Запросы на пулл автоматически закрываются, когда запрошенные коммиты вливаются в репозиторий назначения. При этом генерируется событие, информирующее всех участников разработки, что пулл реквест был принят и влит в основную ветвь.
Событие закрытия пулл реквеста
Так же возможно вручную закрыть пулл реквест в случае, если он был отклонён. Иногда это необходимо в случаях, когда изменения были приняты с помощью git-cherry-pick или другого механизма, который не позволяет обнаружить факт слияния (merge).

Вместо заключения

Надеюсь, это руководство поможет вам в улучшении многих open-source (и не только) проектов.
Несмотря на большое время пребывания на Хабрахабре, это мой первый топик. Пожалуйста, сообщайте в личку или в комментариях обо всех недочётах, которые я мог допустить. Буду исправлять.
Большое спасибо Antiarchitect и другим хабраюзерам за помощь в опубликовании статьи, а так же, разумеется, команде разработчиков GitHub, за столь удобный и бесплатный для open-source сервис.




Сегодня мы пробежимся по всем отличиям и новым возможностям между двумя версиями Bootstrap. Как правило, вам необходимо будет просто переименовать некоторые классы или поменять несколько простых параметров.

Для того чтобы сэкономить вам немного времени, я составил список действий, которые необходимо выполнить при переходе с Bootstrap 3 на Bootstrap 4.

Мы начнем с обсуждения изменений, внесенных в фреймворк Bootstrap 4, затем мы рассмотрим новый способ установки Bootstrap, узнаем как изменились единицы измерения в сетке и как flexbox может помочь при создании адаптивных макетов. Мы также обсудим изменения некоторых компонентов и посмотрим, что происходит в новых версиях JavaScript.

Наконец, мы рассмотрим некоторые из новых компонентов, включая карты, всплывающие подсказки и flexbox. Если вы готовы перенести свой сайт со старой версии Bootstrap 3 на Bootstrap 4, эта статья именно для вас.

Глобальные изменения
Список глобальных изменений в Bootstrap 4:

Смена Less на Sass в CSS файлах.
Смена px на rem в качестве единиц измерения в CSS.
Медиа-запросы теперь ems вместо pxs.
Размер шрифта увеличен с 14px до 16px.
Исходный код Bootstrap
Исходный код Bootstrap 3 содержит перекомпилированный CSS, JavaScript, и шрифты, наряду с исходными Less, JavaScript и документацией.

В Bootstrap v4.0.0-alpha, все файлы Less были заменены на Sass из-за миграции к Sass технологии через libSass. Так как Bootstrap 4 больше не поддерживает glyphicons, папку шрифтов тоже убрали.

Установка Bootstrap 4
Bootstrap 4 предлагает различные варианты для установки. На момент написания статьи, вышел Bootstrap 4 Alpha, поэтому на данный момент не все пакетные менеджеры имеют 4 альфа версию.

Вы можете выбрать нужные параметры по своему усмотрению.

Исходные файлы: Используйте Bootstrap, загрузив полный пакет исходного кода, который включает в себя Sass, JavaScript и файлы документации. Для работы вам потребуется компилятор Sass, Autoprefixer и некоторые дополнительные настройки. Если вам нужны только CSS и JS файлы, вы можете просто подключить их при помощи тега <link> внутри раздела <head> перед другими таблицами стилей.
Bootstrap CDN: Используйте Bootstrap CDN. Добавьте ссылку к тегу <link> внутри раздела <head>.
Менеджер пакетов: Используйте менеджер пакетов, например Bower, npm, meteor или composer для установки Bootstrap. Для этого вам понадобится Sass компилятор и Autoprefixer, для установки официальной скомпилированной версии.
Пользовательские сборки: Если вам нужна только часть CSS или JS Bootstrap файлов, вы можете использовать одну из пользовательских сборок:
Reboot включает в себя переменные/примеси, Normalize и Reset. Без JavaScript.
Grid only включает в себя переменные/примеси, и систему сетки. Без JavaScript.
Flexbox включает в себя весь набор Bootstrap с поддержкой Flexbox, но с пониженной совместимостью браузеров.
Обновление Bootstrap сетки
Система сетки в Bootstrap 4 по-прежнему следует тому же HTML-синтаксису, изменения коснулись лишь единиц измерения.

Например, вы можете использовать те же 12 столбцов в разметке.

<div class="container-fluid">
    <div class="row">
        <div class="col-lg-7 sm-6">
            <div class="row">
                <div class="col-lg-7 sm-4">
                    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
                </div>
                <div class="col-lg-5 sm-8">
                    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
                </div>
            </div>
        </div>
        <div class="col-lg-5 sm-6">
            <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
        </div>
    </div>
</div>
Здесь ничего нового; Bootstrap 3 использует те же самые классы. Тем не менее, классы Bootstrap 4 используют ems а не px, а также они добавили один новый дополнительный размер для очень больших экранов. Перечислим все доступные классы вместе с их размерами экрана.

col-xl - очень большой экран (от 75em)
col-lg - большой экран (от 62em)
col-md - средний экран (от 48em)
col-sm - маленький экран (от 34em)
col-xs - очень маленький экран (менее 34em)
Также стоит рассмотреть классы container и row. Контейнер имеет максимальную ширину в единицах измерения rem, в то время как строка имеет отрицательные margin слева и справа размером в -.9375rem и левый и правый padding размером в 0.9375rem, в Bootstrap 3 которые составляли 15px.

Если вы используете Sass версию Bootstrap 4, вы сможете управлять размером сетки используя следующие переменные:

$grid-columns: количество решеток по горизонтали (по умолчанию 12)
$grid-gutter-width: общий отступ вокруг каждой сетки (по умолчанию 30px)
$grid-float-breakpoint: минимальный размер развернутого navbar (по умолчанию $screen-sm-min)
$grid-float-breakpoint-max: максимальный размер при котором navbar начинает уменьшаться (размер по умолчанию $grid-float-breakpoint – 1)
Обновление компонентов сброса / Bootstrap 4 reboot.css
В Bootstrap 3 мы использовали normalize.css для сброса стандартных стилей CSS, в Bootstrap 4 добавили улучшенную версию под названием reboot.css.

Изменение и обновление классов в Bootstrap 4
В новой версии Bootstrap убрали несколько классов и немного изменили некоторые из старых.

Типография
В Bootstrap типографике используется rem. В отличие от px и em, они не являются фиксированными или относительными единицами измерения. Единицы измерения rem являются динамическими по отношению к корневому тегу HTML. Тем не менее, вы все еще можете использовать px, em и pt в своих Bootstrap проектах.

html{
font-size: 16px; 
}
p{
font-size: 1rem; /* 1rem = 16px */
}
h1 {
    font-size: 1.875rem; /* 30px / 16px = 1.875rem */
}
В приведенном выше примере, для параграфа мы задали значение размера текста в 1rem, что эквивалентно корневому html размером в 16px.

Bootstrap 4 использует единицы измерения rem, для того, чтобы иметь 100% масштабирование всего приложения. Также стоит отметить, что размер HTML тега может быть установлен по вашему усмотрению.

Таблицы
Bootstrap 3 использовал контекстные классы для добавления цвета фона в строках таблицы или отдельных ячеек. В Bootstrap 4, добавили специальный префикс .table-* для каждого контекстного класса.

Смена класса table-condensed
В Bootstrap 3 мы использовали класс .table-condensed для создания более компактной таблицы, без отступов. В Bootstrap 4 переименовали данный класс в .table-sm.

Пример ниже.

<table class="table table-striped">
<thead>
<tr>
<th>Table Header 1</th>
<th>Table Header 2</th>
<th>Table Header 3</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cell 1</td>
<td>Cell 2</td>
<td>Cell 3</td>
</tr>
<tr>
<td>Cell 4</td>
<td>Cell 5</td>
<td>Cell 6</td>
</tr>
<tr>
<td>Cell 7</td>
<td>Cell 8</td>
<td>Cell 9</td>
</tr>
</tbody>
</table>
Формы
Формы имеют некоторые изменения в классах. Два основных изменения это переименование классов .input-lg и .input-sm в .form-control-lg и .form-control-sm без использования .form-group-*.

Также добавили новый класс .form-control-label для центрирования названий по вертикали с классом .form-control.

<form>
  <div class="form-group row">
    <label for="inputEmail3" class="col-sm-2 form-control-label">Email</label>
    <div class="col-sm-10">
      <input type="email" class="form-control form-control-lg" id="inputEmail3" placeholder="Email">
    </div>
  </div>
 
  <div class="form-group row">
    <label for="inputPassword3" class="col-sm-2 form-control-label">Password</label>
    <div class="col-sm-10">
      <input type="password" class="form-control form-control-sm" id="inputPassword3" placeholder="Password">
    </div>
  </div>
 
  <div class="form-group row">
    <div class="col-sm-offset-2 col-sm-10">
      <button type="submit" class="btn btn-primary">Sign in</button>
    </div>
  </div>
</form>
Изменения в JavaScript
В Bootstrap присутствует большое количество JavaScript кода, который необходим для работы некоторых компонентов и так как в самих компонентах изменений не так много, JavaScript в целом почти не изменился.

Вот несколько изменений:

Убрали поддержку IE8: Теперь когда отбросили поддержку IE8, мы можем с легкостью использовать более быструю версию jQuery 2.0
Поддержка ES6: Все плагины были переписаны в ES6 и скомпилированы при помощи Babel, компилятора JavaScript.
Новые возможности
В этой части рассмотрим некоторых из основных новых функций.

Карточки
В Bootstrap 4, вкладки, миниатюры и well были удалены и заменены карточками. Данный компонент можно использовать для отображения информации в качестве страницы или контейнера, который поддерживает различные виды контента, такие как ссылки, текст, изображения, заголовки, колонтитулы и многое другое с различными цветами фона.

Для подключения добавьте классы .card и .card-block к выбранному элементу. Есть также еще несколько классов, которые можно использовать внутри класса .card.

.card-title название
.card-text текст
.card-header заголовок
.card-footer футер
<div class="card">
        <!-- Card Header -->
 
        <div class="card-header">
            Card Header
        </div>
 
        <div class="card-block">
            <!-- Card Title -->
 
            <h4 class="card-title">This is the Card Title</h4><!-- Image -->
            <img alt="" src="http://goo.gl/oxHSMr" width="280"> 
            <!-- Card Text -->
 
            <p class="card-text">These are card text. See? They are
            awesome!</p>
        </div><!-- Card Footer -->
 
        <div class="card-footer">
            Card Footer
        </div>
</div>
Flexbox
Еще одно нововведение в Bootstrap 4 это - технология flexbox. Flexbox позволяет контролировать размер, порядок и выравнивание элементов по нескольким осям, распределение свободного места между элементами и многое другое.

Для того, чтобы использовать Flexbox в своем проекте Bootstrap 4, установите переменную $enable-flex со значением true в файле _variables.scss и после компиляции, ваша сетка сразу же переключится на использование Flexbox модели.

Обратите внимание что Flexbox не имеет поддержку IE9

Заключение
В этой статье мы рассказали вам о всех моментах перехода с Bootstrap 3 на Bootstrap 4. Рекомендуем всегда проверять официальную документацию для будущих обновлений.